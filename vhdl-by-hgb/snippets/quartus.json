{
    "Single-Clock-RAM Inference Old Data": {
        "prefix": [
            "SCOldDataInfRAM", 
            "Single Clock RAM OldData"
        ],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity single_clock_ram is",
            "\tport (",
            "\t\tiClk        : in  std_logic;",
            "\t\tiD          : in  std_logic_vector(7 downto 0);",
            "\t\tiWAddress   : in  integer range 0 to 31;",
            "\t\tiRAddress   : in  integer range 0 to 31;",
            "\t\tiWE         : in  std_logic;",
            "\t\toD          : out std_logic_vector(7 downto 0)",
            "\t);",
            "end single_clock_ram;\n",
            "architecture RTL of single_clock_ram is",
            "\ttype MEM is array(0 to 31) of std_logic_vector(7 downto 0);",
            "\tsignal ram_block : MEM;",
            "begin",
            "\tprocess (iClk)",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then",
            "\t\t\tif (iWE = '1') then",
            "\t\t\t\tram_block(iWAddress) <= iD;",
            "\t\t\tend if;",
            "\t\t\toD <= ram_block(iRAddress); -- oD gets old value during write",
            "\t\tend if;",
            "\tend process;",
            "end RTL;",
            "$0"
        ],
        "description": "A Single-Clock-RAM structure with old data Read-During-Write and Inference from Intel"
    },
    "Single-Clock-RAM Inference New Data": {
        "prefix": [
            "SCOldDataInfRAM",
            "Single Clock RAM NewData"
        ],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity single_clock_ram is",
            "\tport (",
            "\t\tiClk        : in  std_logic;",
            "\t\tiD          : in  std_logic_vector(7 downto 0);",
            "\t\tiWAddress   : in  integer range 0 to 31;",
            "\t\tiRAddress   : in  integer range 0 to 31;",
            "\t\tiWE         : in  std_logic;",
            "\t\toD          : out std_logic_vector(7 downto 0)",
            "\t);",
            "end single_clock_ram;\n",
            "architecture RTL of single_clock_ram is",
            "\ttype MEM is array(0 to 31) of std_logic_vector(7 downto 0);",
            "begin",
            "\tprocess (iClk)",
            "\t\tvariable ram_block : MEM;",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then",
            "\t\t\tif (iWE = '1') then",
            "\t\t\t\tram_block(iWAddress) := iD;",
            "\t\t\tend if;",
            "\t\t\toD <= ram_block(iRAddress);",
            "\t\t\t-- VHDL semantics imply that oD doesn't get data",
            "\t\t\t-- in this clock cycle",
            "\t\tend if;",
            "\tend process;",
            "end RTL;",
            "$0"
        ],
        "description": "A Single-Clock-RAM structure with new data Read-During-Write and Inference from Intel"
    },
    "Single-Clock-RAM Inference Concurrent": {
        "prefix": [
            "SCConcurrentInfRAM",
            "Single Clock Concurrent RAM"
        ],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity single_clock_ram is",
            "\tport (",
            "\t\tiClk        : in  std_logic;",
            "\t\tiD          : in  std_logic_vector(7 downto 0);",
            "\t\tiWAddress   : in  integer range 0 to 31;",
            "\t\tiRAddress   : in  integer range 0 to 31;",
            "\t\tiWE         : in  std_logic;",
            "\t\toD          : out std_logic_vector(7 downto 0)",
            "\t);",
            "end single_clock_ram;\n",
            "architecture RTL of single_clock_ram is",
            "\ttype MEM is array(0 to 31) of std_logic_vector(7 downto 0);",
            "\tsignal ram_block : MEM;",
            "\tsignal read_address_reg: integer range 0 to 31;",
            "begin",
            "\tprocess (iClk)",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then",
            "\t\t\tif (iWE = '1') then",
            "\t\t\t\tram_block(iWAddress) := iD;",
            "\t\t\tend if;",
            "\t\t\tread_address_reg <= iRAddress;",
            "\t\tend if;",
            "\tend process;",
            "\toD <= ram_block(read_address_reg);",
            "end RTL;",
            "$0"
        ],
        "description": "A Single-Clock-RAM structure with concurrent signal and Inference from Intel"
    },
    "Dual-Clock-RAM Inference": {
        "prefix": [
            "DCInfRAM", 
            "Simple Dual RAM"
        ],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity dual_clock_ram is",
            "\tport (",
            "\t\tiClk1, iClk2: in  std_logic;",
            "\t\tiD          : in  std_logic_vector(7 downto 0);",
            "\t\tiWAddress   : in  integer range 0 to 31;",
            "\t\tiRAddress   : in  integer range 0 to 31;",
            "\t\tiWE         : in  std_logic;",
            "\t\toD          : out std_logic_vector(7 downto 0)",
            "\t);",
            "end dual_clock_ram;\n",
            "architecture RTL of dual_clock_ram is",
            "\ttype MEM is array(0 to 31) of std_logic_vector(7 downto 0);",
            "\tsignal ram_block : MEM;",
            "\tsignal read_address_reg: integer range 0 to 31;",
            "begin",
            "\tprocess (iClk1)",
            "\tbegin",
            "\t\tif (rising_edge(iClk1)) then",
            "\t\t\tif (iWE = '1') then",
            "\t\t\t\tram_block(iWAddress) <= iD;",
            "\t\t\tend if;",
            "\t\tend if;",
            "\tend process;\n",
            "\tprocess (iClk2)",
            "\tbegin",
            "\t\tif (rising_edge(iClk2)) then",
            "\t\t\toD <= ram_block(read_address_reg);",
            "\t\t\tread_address_reg <= iRAddress;",
            "\t\tend if;",
            "\tend process;",
            "end RTL;",
            "$0"
        ],
        "description": "A Dual-Clock-RAM structure with Inference from Intel"
    },
    "True Dual-Port-RAM Inference": {
        "prefix": [
            "TrueDPInfRAM", 
            "True Dual Port RAM"
        ],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity true_dual_clock_ram is",
            "\tgeneric (",
            "\t\tgWiData    : natural := 8;",
            "\t\tgWiAddr    : natural := 6",
            "\t);",
            "\tport (",
            "\t\tiClk       : in  std_logic;",
            "\t\tiD1        : in  std_logic_vector((gWiData - 1) downto 0);",
            "\t\tiD2        : in  std_logic_vector((gWiData - 1) downto 0);",
            "\t\tiAddress1  : in  natural range 0 to 2**gWiAddr - 1;",
            "\t\tiAddress2  : in  natural range 0 to 2**gWiAddr - 1;",
            "\t\tiWE1       : in  std_logic;",
            "\t\tiWE2       : in  std_logic;",
            "\t\toD1        : out std_logic_vector((gWiData - 1) downto 0)",
            "\t\toD2        : out std_logic_vector((gWiData - 1) downto 0)",
            "\t);",
            "end true_dual_clock_ram;\n",
            "architecture RTL of true_dual_clock_ram is",
            "\ttype MEM is array((2**gWiAddr - 1) downto 0) of std_logic_vector((gWiData - 1) downto 0);",
            "\tsignal ram_block : MEM;",
            "begin",
            "\tprocess (iClk)",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then    -- Port 1",
            "\t\t\tif (iWE1 = '1') then",
            "\t\t\t\tram_block(iAddress1) <= iD1;",
            "\t\t\t\t-- Read-during-write on same port returns NEW data",
            "\t\t\t\toD1 <= iD1;",
            "\t\t\tend if;",
            "\t\t\t-- Read-during-write on mixed port returns OLD data",
            "\t\t\toD1 <= ram_block(iAddress1);",
            "\t\tend if;",
            "\tend process;\n",
            "\tprocess (iClk)",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then    -- Port 2",
            "\t\t\tif (iWE2 = '1') then",
            "\t\t\t\tram_block(iAddress2) <= iD2;",
            "\t\t\t\t-- Read-during-write on same port returns NEW data",
            "\t\t\t\toD2 <= iD2;",
            "\t\t\tend if;",
            "\t\t\t-- Read-during-write on mixed port returns OLD data",
            "\t\t\toD2 <= ram_block(iAddress2);",
            "\t\tend if;",
            "\tend process;",
            "end RTL;",
            "$0"
        ],
        "description": "A True-Dual-Port-RAM structure with Inference from Intel"
    },
    "Synchronous-ROM Inference": {
        "prefix": [
            "SyncInfROM-3Bit", 
            "Synch ROM 3 AddrBit"
        ],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity sync_rom is",
            "\tport (",
            "\t\tiClk     : in  std_logic;",
            "\t\tiAddress : in std_logic_vector(2 downto 0);",
            "\t\toD       : out std_logic_vector(5 downto 0)",
            "\t);",
            "end sync_rom;\n",
            "architecture RTL of sync_rom is",
            "begin",
            "\tprocess (iClk)",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then",
            "\t\t\tcase iAddress is",
            "\t\t\t\twhen \"000\" => oD <= \"101111\";",
            "\t\t\t\twhen \"001\" => oD <= \"110110\";",
            "\t\t\t\twhen \"010\" => oD <= \"000001\";",
            "\t\t\t\twhen \"011\" => oD <= \"101010\";",
            "\t\t\t\twhen \"100\" => oD <= \"101111\";",
            "\t\t\t\twhen \"101\" => oD <= \"110110\";",
            "\t\t\t\twhen \"110\" => oD <= \"000001\";",
            "\t\t\t\twhen \"111\" => oD <= \"101010\";",
            "\t\t\t\twhen others => oD <= \"101111\";",
            "\t\t\tend case;",
            "\t\tend if;",
            "\tend process;",
            "end RTL;",
            "$0"
        ],
        "description": "A Synchronous ROM structure with 3 Bit address and Inference from Intel"
    },
    "Dual Port ROM Function Inference": {
        "prefix": ["DPFuncInfROM", "Dual Port ROM with Init-Func"],
        "body": [
            "library ieee;",
            "use ieee.std_logic_1164.all;\n",
            "entity dual_port_rom is",
            "\tgeneric (",
            "\t\tgWiData    : natural := 0;",
            "\t\tgWiAddr    : natural := 0",
            "\t);",
            "\tport (",
            "\t\tiClk       : in  std_logic;",
            "\t\tiAddress1  : in  natural range 0 to 2**gWiAddr - 1;",
            "\t\tiAddress2  : in  natural range 0 to 2**gWiAddr - 1;",
            "\t\toD1        : out std_logic_vector((gWiData - 1) downto 0)",
            "\t\toD2        : out std_logic_vector((gWiData - 1) downto 0)",
            "\t);",
            "end dual_port_rom;\n",
            "architecture RTL of dual_port_rom is",
            "\tsubtype word_t is std_logic_vector((gWiData-1) downto 0);",
            "\ttype memory_t is array(2**gWiAddr - 1 downto 0) of word_t;\n",
            "\tfunction init_rom",
            "\t\treturn memory_t is ",
            "\t\tvariable tmp : memory_t := (others => (others => '0'));",
            "\tbegin ",
            "\t\tfor addr_pos in 0 to 2**gWiAddr - 1 loop ",
            "\t\t\t-- Initialize each address with the address itself",
            "\t\t\ttmp(addr_pos) := std_logic_vector(to_unsigned(addr_pos, gWiData));",
            "\t\tend loop;",
            "\t\treturn tmp;",
            "\tend init_rom;\n",
            "\t-- Declare the ROM signal and specify a default initialization value",
            "\tsignal rom : memory_t := init_rom;",
            "begin",
            "\tprocess (iClk)",
            "\tbegin",
            "\t\tif (rising_edge(iClk)) then",
            "\t\t\toD1 <= rom(iAddress1);",
            "\t\t\toD2 <= rom(iAddress2);",
            "\t\tend if;",
            "\tend process;",
            "end RTL;",
            "$0"
        ],
        "description": "A Dual Ported ROM structure with init-function-addressing and Inference from Intel"
    }
}